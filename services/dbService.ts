
import { supabase } from '../supabaseClient';
import { Lead, CalculatorState, PaymentState, EmailState, QuotationData, Template } from '../types';

export interface WorkspaceData {
    quotation: QuotationData | null;
    financials: CalculatorState;
    payment: PaymentState;
    email: EmailState;
}

// --- Mappers ---

const mapLeadFromDB = (dbLead: any): Lead => ({
    id: dbLead.id,
    name: dbLead.name,
    phone: dbLead.phone,
    email: dbLead.email,
    status: dbLead.status,
    destination: dbLead.destination,
    travelDate: dbLead.travel_date, // Map snake_case to camelCase
    pax: dbLead.pax,
    budget: dbLead.budget,
    notes: dbLead.notes,
    createdAt: new Date(dbLead.created_at).getTime() // Convert DB timestamp string to number
});

const mapLeadToDB = (lead: Lead) => ({
    // id is auto-generated by DB on insert
    name: lead.name,
    phone: lead.phone,
    email: lead.email,
    status: lead.status,
    destination: lead.destination,
    travel_date: lead.travelDate,
    pax: lead.pax,
    budget: lead.budget,
    notes: lead.notes,
    // created_at auto-generated
});

export const dbService = {

    // --- LEADS ---

    async getLeads(): Promise<Lead[]> {
        const { data, error } = await supabase
            .from('leads')
            .select('*')
            .order('created_at', { ascending: false });

        if (error) {
            console.error("Supabase Error (getLeads):", error);
            throw new Error("Failed to fetch leads");
        }
        return (data || []).map(mapLeadFromDB);
    },

    async createLead(lead: Lead): Promise<Lead> {
        const payload = mapLeadToDB(lead);

        const { data, error } = await supabase
            .from('leads')
            .insert(payload)
            .select()
            .single();

        if (error) {
            console.error("Supabase Error (createLead):", error);
            throw new Error("Failed to create lead");
        }
        return mapLeadFromDB(data);
    },

    async updateLead(lead: Lead): Promise<Lead> {
        if (!lead.id) throw new Error("Lead ID missing for update");

        const payload = mapLeadToDB(lead);

        // Remove ID from payload to avoid changing primary key (though Supabase usually ignores it)

        const { data, error } = await supabase
            .from('leads')
            .update(payload)
            .eq('id', lead.id)
            .select()
            .single();

        if (error) {
            console.error("Supabase Error (updateLead):", error);
            throw new Error("Failed to update lead");
        }
        return mapLeadFromDB(data);
    },

    async deleteLead(id: number): Promise<void> {
        const { error } = await supabase
            .from('leads')
            .delete()
            .eq('id', id);

        if (error) {
            console.error("Supabase Error (deleteLead):", error);
            throw new Error("Failed to delete lead");
        }
    },

    // --- WORKSPACES ---

    async getWorkspace(leadId: number): Promise<WorkspaceData | null> {
        const { data, error } = await supabase
            .from('workspaces')
            .select('*')
            .eq('lead_id', leadId)
            .maybeSingle();

        if (error) {
            console.error("Supabase Error (getWorkspace):", error);
            return null;
        }

        if (!data) return null;

        // Map snake_case DB columns to App state structure
        return {
            quotation: data.quotation_data,
            financials: data.financial_state,
            payment: data.payment_state,
            email: data.email_state
        };
    },

    async saveWorkspace(leadId: number, data: WorkspaceData, status: string): Promise<void> {
        // 1. Check if workspace exists for this lead
        const { data: existing } = await supabase
            .from('workspaces')
            .select('id')
            .eq('lead_id', leadId)
            .maybeSingle();

        const payload = {
            lead_id: leadId,
            quotation_data: data.quotation,
            financial_state: data.financials,
            payment_state: data.payment,
            email_state: data.email,
            updated_at: new Date().toISOString()
        };

        let wsError;

        if (existing) {
            // Update
            const { error } = await supabase
                .from('workspaces')
                .update(payload)
                .eq('lead_id', leadId);
            wsError = error;
        } else {
            // Insert
            const { error } = await supabase
                .from('workspaces')
                .insert(payload);
            wsError = error;
        }

        if (wsError) {
            console.error("Supabase Error (saveWorkspace):", wsError);
            throw new Error("Failed to save workspace");
        }

        // 2. Update Lead Status
        const { error: leadError } = await supabase
            .from('leads')
            .update({ status: status })
            .eq('id', leadId);

        if (leadError) {
            console.error("Supabase Error (updateStatus):", leadError);
        }
    },
    // --- TEMPLATES ---

    async getTemplates(): Promise<Template[]> {
        const { data, error } = await supabase
            .from('templates')
            .select('*')
            .order('created_at', { ascending: false });

        if (error) {
            console.error("Supabase Error (getTemplates):", error);
            // Don't throw here, just return empty to avoid breaking UI on init
            return [];
        }

        return (data || []).map((t: any) => ({
            id: t.id,
            name: t.name,
            description: t.description,
            tags: t.tags || [],
            fileData: t.file_data,
            createdAt: new Date(t.created_at).getTime()
        }));
    },

    async saveTemplate(template: Template): Promise<Template> {
        const payload = {
            name: template.name,
            description: template.description,
            tags: template.tags,
            file_data: template.fileData
        };

        const { data, error } = await supabase
            .from('templates')
            .insert(payload)
            .select()
            .single();

        if (error) {
            console.error("Supabase Error (saveTemplate):", error);
            if (error.code === '42P01' || error.code === 'PGRST205') {
                throw new Error("Missing Database Table! Please run the 'supabase_templates.sql' script in your Supabase SQL Editor.");
            }
            throw new Error(`Failed to save template: ${error.message} (Code: ${error.code})`);
        }

        return {
            id: data.id,
            name: data.name,
            description: data.description,
            tags: data.tags || [],
            fileData: data.file_data,
            createdAt: new Date(data.created_at).getTime()
        };
    },

    async deleteTemplate(id: number): Promise<void> {
        const { error } = await supabase
            .from('templates')
            .delete()
            .eq('id', id);

        if (error) {
            console.error("Supabase Error (deleteTemplate):", error);
            throw new Error(`Failed to delete template: ${error.message}`);
        }
    },

    // --- SETTINGS ---
    async getSettings(): Promise<any | null> {
        const { data, error } = await supabase
            .from('settings')
            .select('*')
            .eq('id', 1)
            .maybeSingle();

        if (error) {
            console.error("Supabase Error (getSettings):", error);
            return null;
        }

        return data?.value || null;
    },

    async saveSettings(settings: any): Promise<void> {
        const { error } = await supabase
            .from('settings')
            .upsert({ id: 1, value: settings, updated_at: new Date().toISOString() });

        if (error) {
            console.error("Supabase Error (saveSettings):", error);
            throw new Error("Failed to save settings to Supabase");
        }
    }
};
